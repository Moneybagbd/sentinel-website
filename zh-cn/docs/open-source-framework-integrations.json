{
  "filename": "open-source-framework-integrations.md",
  "__html": "<h1>开源框架适配</h1>\n<h2>目录</h2>\n<ul>\n<li><a href=\"#web-servlet\">Web Servlet</a></li>\n<li><a href=\"#dubbo\">Dubbo</a></li>\n<li><a href=\"#spring-cloud\">Spring Boot / Spring Cloud</a></li>\n<li><a href=\"#grpc\">gRPC</a></li>\n<li><a href=\"#apache-rocketmq\">Apache RocketMQ</a></li>\n</ul>\n<blockquote>\n<p><strong>注：适配模块仅提供相应适配功能，若希望接入 Sentinel 控制台，请务必参考 <a href=\"https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0\">Sentinel 控制台文档</a>。</strong></p>\n</blockquote>\n<h2>Web Servlet</h2>\n<p>Sentinel 提供与 Servlet 的整合，可以对 Web 请求进行流量控制。使用时需引入以下模块（以 Maven 为例）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-web-servlet<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>您只需要在 Web 容器中的 <code>web.xml</code> 配置文件中进行如下配置即可开启 Sentinel 支持：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-name</span>&gt;</span>SentinelCommonFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-name</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-class</span>&gt;</span>com.alibaba.csp.sentinel.adapter.servlet.CommonFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-class</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-mapping</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">filter-name</span>&gt;</span>SentinelCommonFilter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-name</span>&gt;</span>\n\t<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">url-pattern</span>&gt;</span>/*<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">url-pattern</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">filter-mapping</span>&gt;</span>\n</code></pre>\n<p>若是 Spring 应用可以通过 Spring 进行配置，例如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FilterConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> FilterRegistrationBean <span class=\"hljs-title\">sentinelFilterRegistration</span><span class=\"hljs-params\">()</span> </span>{\n        FilterRegistrationBean&lt;Filter&gt; registration = <span class=\"hljs-keyword\">new</span> FilterRegistrationBean&lt;&gt;();\n        registration.setFilter(<span class=\"hljs-keyword\">new</span> CommonFilter());\n        registration.addUrlPatterns(<span class=\"hljs-string\">\"/*\"</span>);\n        registration.setName(<span class=\"hljs-string\">\"sentinelFilter\"</span>);\n        registration.setOrder(<span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-keyword\">return</span> registration;\n    }\n}\n</code></pre>\n<p>默认情况下，当请求被限流时会返回默认的提示页面。您也可以通过 <code>WebServletConfig.setBlockPage(blockPage)</code> 方法设定自定义的跳转 URL，当请求被限流时会自动跳转至设定好的 URL。同样也可以实现 <code>UrlBlockHandler</code> 接口并编写定制化的限流处理逻辑，然后将其注册至 <code>WebCallbackManager</code> 中。</p>\n<p><strong>注意</strong>：Sentinel Web Filter 会将每个到来的不同的 URL 都作为不同的资源处理，因此对于 REST 风格的 API，需要自行实现 <code>UrlCleaner</code> 接口清洗一下资源（比如将满足 <code>/foo/:id</code> 的 URL 都归到 <code>/foo/*</code> 资源下），然后将其注册至 <code>WebCallbackManager</code> 中。否则会导致资源数量过多，超出资源数量阈值（目前是 6000）时多出的资源的规则将 <strong>不会生效</strong>。</p>\n<p>若希望对 HTTP 请求按照来源限流，则可以自己实现 <code>RequestOriginParser</code> 接口从 HTTP 请求中解析 origin 并注册至 <code>WebCallbackManager</code> 中。</p>\n<p>如果您正在使用 Spring Boot / Spring Cloud，那么可以通过引入 Spring Cloud Sentinel Starter 来更方便地整合 Sentinel，详情请见 <a href=\"https://github.com/spring-cloud-incubator/spring-cloud-alibabacloud/blob/master/README-zh.md\">Spring Cloud Alibaba</a>。</p>\n<h2>Dubbo</h2>\n<p>Sentinel 提供 Dubbo 的相关适配 <a href=\"https://github.com/dubbo/dubbo-sentinel-support\">Sentinel Dubbo Adapter</a>，主要包括针对 Service Provider 和 Service Consumer 实现的 Filter。使用时需引入以下模块（以 Maven 为例）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-dubbo-adapter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>引入此依赖后，Dubbo 的服务接口和方法（包括调用端和服务端）就会成为 Sentinel 中的资源，在配置了规则后就可以自动享受到 Sentinel 的防护能力。</p>\n<blockquote>\n<p><strong>注：若希望接入 Dashboard，请参考 <a href=\"https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-dubbo/README.md#sentinel-dashboard\">接入控制台的步骤</a>。只引入 Sentinel Dubbo Adapter 无法接入控制台！</strong></p>\n</blockquote>\n<p>若不希望开启 Sentinel Dubbo Adapter 中的某个 Filter，可以手动关闭对应的 Filter，比如：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- 关闭 Sentinel 对应的 Service Consumer Filter --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dubbo:consumer</span> <span class=\"hljs-attr\">filter</span>=<span class=\"hljs-string\">\"-sentinel.dubbo.consumer.filter\"</span>/&gt;</span>\n</code></pre>\n<p>限流粒度可以是服务接口和服务方法两种粒度：</p>\n<ul>\n<li>服务接口：resourceName 为 <code>接口全限定名</code>，如 <code>com.alibaba.csp.sentinel.demo.dubbo.FooService</code></li>\n<li>服务方法：resourceName 为 <code>接口全限定名:方法签名</code>，如 <code>com.alibaba.csp.sentinel.demo.dubbo.FooService:sayHello(java.lang.String)</code></li>\n</ul>\n<p>从 0.1.1 版本开始，Sentinel Dubbo Adapter 还支持配置全局的 fallback 函数，可以在 Dubbo 服务被限流/降级/负载保护的时候进行相应的 fallback 处理。用户只需要实现自定义的 <a href=\"https://github.com/alibaba/Sentinel/blob/master/sentinel-adapter/sentinel-dubbo-adapter/src/main/java/com/alibaba/csp/sentinel/adapter/dubbo/fallback/DubboFallback.java\"><code>DubboFallback</code></a> 接口，并通过 <code>DubboFallbackRegistry</code> 注册即可。默认情况会直接将 <code>BlockException</code> 包装后抛出。同时，我们还可以配合 <a href=\"http://dubbo.incubator.apache.org/zh-cn/docs/user/demos/local-mock.html\">Dubbo 的 fallback 机制</a> 来为降级的服务提供替代的实现。</p>\n<blockquote>\n<p>注：一般情况下熔断降级 / fallback 用于调用端（客户端）。</p>\n</blockquote>\n<p>我们提供了 Dubbo 的相关示例，请见 <a href=\"https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-dubbo\">sentinel-demo-dubbo</a>。</p>\n<p>有关 Sentinel 在 Dubbo 中的最佳实践，请参考 <a href=\"http://dubbo.incubator.apache.org/zh-cn/blog/sentinel-introduction-for-dubbo.html\">Sentinel: Dubbo 服务的流量哨兵</a>。</p>\n<p>关于 Dubbo Filter 的更多信息，请参考 <a href=\"http://dubbo.incubator.apache.org/zh-cn/docs/dev/impls/filter.html\">Dubbo Filter 文档</a>。</p>\n<h2>Spring Cloud</h2>\n<p><a href=\"https://github.com/spring-cloud-incubator/spring-cloud-alibaba\">Spring Cloud Alibaba</a> 致力于提供分布式应用服务开发的一站式解决方案。Sentinel 与 Spring Cloud 的整合见 <a href=\"https://github.com/spring-cloud-incubator/spring-cloud-alibaba/blob/master/spring-cloud-alibaba-examples/sentinel-example/sentinel-core-example/readme-zh.md\">Sentinel Spring Cloud Starter</a>。</p>\n<h2>gRPC</h2>\n<p>Sentinel 提供与 <a href=\"https://github.com/grpc/grpc-java\">gRPC Java</a> 的整合，以 gRPC <a href=\"https://grpc.io/grpc-java/javadoc/io/grpc/ServerInterceptor.html\">ServerInterceptor</a> 和 <a href=\"https://grpc.io/grpc-java/javadoc/io/grpc/ClientInterceptor.html\">ClientInterceptor</a> 的形式保护 gRPC 服务资源。使用时需引入以下模块（以 Maven 为例）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-grpc-adapter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>在使用 Sentinel gRPC Adapter 时，只需要将对应的 <code>Interceptor</code> 注册至对应的客户端或服务端中。其中客户端的示例如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ServiceClient</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ManagedChannel channel;\n\n    ServiceClient(String host, <span class=\"hljs-keyword\">int</span> port) {\n        <span class=\"hljs-keyword\">this</span>.channel = ManagedChannelBuilder.forAddress(host, port)\n            .intercept(<span class=\"hljs-keyword\">new</span> SentinelGrpcClientInterceptor()) <span class=\"hljs-comment\">// 在此处注册拦截器</span>\n            .build();\n        <span class=\"hljs-comment\">// 在此处初始化客户端 stub 类</span>\n    }\n}\n</code></pre>\n<p>服务端的示例如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> io.grpc.Server;\n\nServer server = ServerBuilder.forPort(port)\n     .addService(<span class=\"hljs-keyword\">new</span> MyServiceImpl()) <span class=\"hljs-comment\">// 添加自己的服务实现</span>\n     .intercept(<span class=\"hljs-keyword\">new</span> SentinelGrpcServerInterceptor()) <span class=\"hljs-comment\">// 在此处注册拦截器</span>\n     .build();\n</code></pre>\n<p>注意：由于 gRPC 拦截器中 ClientCall/ServerCall 以回调的形式进行请求响应信息的获取，每次 gRPC 服务调用计算出的 RT 可能会不准确。Sentinel gRPC Adapter 目前只支持 unary call。</p>\n<h2>Apache RocketMQ</h2>\n<p>在 Apache RocketMQ 中，当消费者去消费消息的时候，无论是通过 pull 的方式还是 push 的方式，都可能会出现大批量的消息突刺。如果此时要处理所有消息，很可能会导致系统负载过高，影响稳定性。但其实可能后面几秒之内都没有消息投递，若直接把多余的消息丢掉则没有充分利用系统处理消息的能力。我们希望可以把消息突刺均摊到一段时间内，让系统负载保持在消息处理水位之下的同时尽可能地处理更多消息，从而起到“削峰填谷”的效果：</p>\n<p><img src=\"https://github.com/alibaba/Sentinel/wiki/image/mq-traffic-peak-clipping.png\" alt=\"削峰填谷\"></p>\n<p>上图中红色的部分代表超出消息处理能力的部分。我们可以看到消息突刺往往都是瞬时的、不规律的，其后一段时间系统往往都会有空闲资源。我们希望把红色的那部分消息平摊到后面空闲时去处理，这样既可以保证系统负载处在一个稳定的水位，又可以尽可能地处理更多消息。Sentinel 专门为这种场景提供了<a href=\"https://github.com/alibaba/Sentinel/wiki/%E9%99%90%E6%B5%81---%E5%8C%80%E9%80%9F%E5%99%A8\">匀速器</a>的特性，可以把突然到来的大量请求以匀速的形式均摊，以固定的间隔时间让请求通过，以稳定的速度逐步处理这些请求，起到“削峰填谷”的效果，从而避免流量突刺造成系统负载过高。同时堆积的请求将会排队，逐步进行处理；当请求排队预计超过最大超时时长的时候则直接拒绝，而不是拒绝全部请求。</p>\n<p>比如在 RocketMQ 的场景下配置了匀速模式下请求 QPS 为 5，则会每 200 ms 处理一条消息，多余的处理任务将排队；同时设置了超时时间为 5 s，预计排队时长超过 5 s 的处理任务将会直接被拒绝。示意图如下图所示：</p>\n<p><img src=\"https://github.com/alibaba/Sentinel/wiki/image/uniform-speed-queue.png\" alt=\"Uniform rate\"></p>\n<p>RocketMQ 用户可以根据不同的 group 和不同的 topic 分别设置限流规则，限流控制模式设置为匀速器模式（<code>RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER</code>），比如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initFlowControlRule</span><span class=\"hljs-params\">()</span> </span>{\n    FlowRule rule = <span class=\"hljs-keyword\">new</span> FlowRule();\n    rule.setResource(KEY); <span class=\"hljs-comment\">// 对应的 key 为 `groupName:topicName`</span>\n    rule.setCount(<span class=\"hljs-number\">5</span>);\n    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);\n    rule.setLimitApp(<span class=\"hljs-string\">\"default\"</span>);\n\n    <span class=\"hljs-comment\">// 匀速器模式下，设置了 QPS 为 5，则请求每 200 ms 允许通过 1 个</span>\n    rule.setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER);\n    <span class=\"hljs-comment\">// 如果更多的请求到达，这些请求会被置于虚拟的等待队列中。等待队列有一个 max timeout，如果请求预计的等待时间超过这个时间会直接被 block</span>\n    <span class=\"hljs-comment\">// 在这里，timeout 为 5s</span>\n    rule.setMaxQueueingTimeMs(<span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">1000</span>);\n    FlowRuleManager.loadRules(Collections.singletonList(rule));\n}\n</code></pre>\n<p>结合 RocketMQ Client 使用 Sentinel 时，用户需要在处理消息时手动埋点。详情请见 <a href=\"https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-rocketmq\">Sentinel RocketMQ Demo</a>。相关 Blog 见 <a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel-%E4%B8%BA-RocketMQ-%E4%BF%9D%E9%A9%BE%E6%8A%A4%E8%88%AA\">Sentinel 为 RocketMQ 保驾护航</a>。</p>\n",
  "link": "/zh-cn/docs/open-source-framework-integrations.html",
  "meta": {}
}