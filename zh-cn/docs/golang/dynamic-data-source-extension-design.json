{
  "filename": "dynamic-data-source-extension-design.md",
  "__html": "<h1>动态数据源扩展</h1>\n<p>这个 Wiki 主要描述 <a href=\"https://github.com/alibaba/sentinel-golang\">sentinel-golang</a> 的动态数据源扩展的设计。目前 Sentinel 内部的限流、熔断等策略都是基于规则来实现的，提供动态数据源扩展的目的，就是希望将规则数据或则其余的 properties 的更新操作通过一些配置中心中间件(比如 etcd,conful,nacos-go 等等)来实现动态更新。整体数据流的pipeline大概就是：Sentinel board 或则是其余的 Config center dashboard --&gt; 配置中心中间件 --&gt; sentinel， 从而实现 properties 的动态更新。</p>\n<h2>Overall</h2>\n<p>动态数据源扩展的整体架构和 Java 版本是一样的，可以参考下图所示架构图：</p>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/45406233-645e8380-b698-11e8-8199-0c917403238f.png\" alt=\"\"></p>\n<p>整体的设计分为两大块：property的抽象和DataSource数据源的抽象。</p>\n<ol>\n<li>Property的抽象作为DataSource的下游，负责具体property的处理，将最新的property更新到下游的组件(比如流控规则、限流规则、配置模块等)。</li>\n<li>DataSource的抽象主要是负责建立与配置中心中间件建立长连接，基于类似于Watcher的监听机制来监听具体property的变化，并将property变化通过Property的抽象处理。</li>\n</ol>\n<h2>Property的设计</h2>\n<p>Property的抽象通过接口 <code>PropertyHandler</code> 接口来定义，PropertyHandler的职责边界是：处理输入的property字节，并将最新的property更新到下游相关联的核心组件。</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> PropertyHandler <span class=\"hljs-keyword\">interface</span> {\n\t<span class=\"hljs-comment\">// check whether the current src is consistent with last update property</span>\n\tisPropertyConsistent(src <span class=\"hljs-keyword\">interface</span>{}) <span class=\"hljs-keyword\">bool</span>\n\t<span class=\"hljs-comment\">// handle the current property</span>\n\tHandle(src []<span class=\"hljs-keyword\">byte</span>) error\n}\n</code></pre>\n<p><code>PropertyHandler</code> 的定义非常简单，只包含两个函数：</p>\n<ol>\n<li><code>isPropertyConsistent</code> 函数用于判断当前更新的 property 是否和上次更新的一样，如果一样就不做更新，类似于一个缓存过滤机制。</li>\n<li><code>Handle</code> 函数则负责具体的 property 处理逻辑，包括将字节数组转换成实际的 property ，并将该 property 更新到下游相关联的核心组件。</li>\n</ol>\n<p>Sentinel 提供了 <code>PropertyHandler</code> 的一个默认的实现：<code>DefaultPropertyHandler</code>。</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> DefaultPropertyHandler <span class=\"hljs-keyword\">struct</span> {\n\tlastUpdateProperty <span class=\"hljs-keyword\">interface</span>{}\n\n\tconverter PropertyConverter\n\tupdater   PropertyUpdater\n}\n</code></pre>\n<p>这里的一个DefaultPropertyHandler实例将用于处理一个 property type。 属性<code>lastUpdateProperty</code> 用于缓存上次更新的property，用于过滤无效property。 此外还包含两个函数属性, 下面先看定义：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// PropertyConverter func is to converter source message bytes to the specific property.</span>\n<span class=\"hljs-comment\">// the first  return value: is the real property;</span>\n<span class=\"hljs-comment\">// the second return value: return nil if succeed to convert src, if not return the detailed error when convert src.</span>\n<span class=\"hljs-comment\">// if src is nil or len(src)==0, the return value is (nil,nil)</span>\n<span class=\"hljs-keyword\">type</span> PropertyConverter <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(src []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">interface</span>{}, error)</span>\n\n// <span class=\"hljs-title\">PropertyUpdater</span> <span class=\"hljs-title\">func</span> <span class=\"hljs-title\">is</span> <span class=\"hljs-title\">to</span> <span class=\"hljs-title\">update</span> <span class=\"hljs-title\">the</span> <span class=\"hljs-title\">specific</span> <span class=\"hljs-title\">properties</span> <span class=\"hljs-title\">to</span> <span class=\"hljs-title\">downstream</span>.\n// <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">nil</span> <span class=\"hljs-title\">if</span> <span class=\"hljs-title\">succeed</span> <span class=\"hljs-title\">to</span> <span class=\"hljs-title\">update</span>, <span class=\"hljs-title\">if</span> <span class=\"hljs-title\">not</span>, <span class=\"hljs-title\">return</span> <span class=\"hljs-title\">the</span> <span class=\"hljs-title\">error</span>.\n<span class=\"hljs-title\">type</span> <span class=\"hljs-title\">PropertyUpdater</span> <span class=\"hljs-title\">func</span><span class=\"hljs-params\">(data <span class=\"hljs-keyword\">interface</span>{})</span> <span class=\"hljs-title\">error</span>\n</span></code></pre>\n<p>PropertyConverter：会将property的字节数组反序列化成具体的property类型。 具体的反序列化协议依据用户的实现，提供比较高的灵活性，Sentinel默认会提供一个json反序列化的实现，用户也可以根据自己的需求，自己实现自己的反序列化方式。</p>\n<p>PropertyUpdater：会将具体的property类型数据，更新到相关联的下游的核心组件。比如 []FlowRule 类型的property会被更新到 flow module的flow manager里面。这里sentinel框架会提供所有支持的动态 property 的update函数的实现，用户对这个理论上来说是不感知的。</p>\n<p>这里需要强调的是，每种动态property类型的PropertyConverter和PropertyUpdater是成对出现在<code>DefaultPropertyHandler</code>中的。</p>\n<p><code>DefaultPropertyHandler</code> 具体的 <code>Handle</code> 函数的实现可以参考源码：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(h *DefaultPropertyHandler)</span> <span class=\"hljs-title\">Handle</span><span class=\"hljs-params\">(src []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n\t\t<span class=\"hljs-keyword\">if</span> err := <span class=\"hljs-built_in\">recover</span>(); err != <span class=\"hljs-literal\">nil</span> &amp;&amp; logger != <span class=\"hljs-literal\">nil</span> {\n\t\t\tlogger.Panicf(<span class=\"hljs-string\">\"Unexpected panic: %+v\"</span>, errors.Errorf(<span class=\"hljs-string\">\"%+v\"</span>, err))\n\t\t}\n\t}()\n\t<span class=\"hljs-comment\">// convert to target property</span>\n\trealProperty, err := h.converter(src)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> err\n\t}\n\tisConsistent := h.isPropertyConsistent(realProperty)\n\t<span class=\"hljs-keyword\">if</span> isConsistent {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t}\n\t<span class=\"hljs-keyword\">return</span> h.updater(realProperty)\n}\n</code></pre>\n<p>整体的workflow如下：</p>\n<ol>\n<li>调用converter将 []bytes 转成具体的property；</li>\n<li>通过缓存过滤无效property；</li>\n<li>更新实际的property到相关联的下游组件。</li>\n</ol>\n<p>针对Sentinel 现有组件可能的动态 property，Sentinel提供了一个 helper.go 的函数集，里面包含了一系列的 Converter 和 Updater。源码在：\n<a href=\"https://github.com/alibaba/sentinel-golang/blob/master/ext/datasource/helper.go\">helper.go</a>\nhelper.go里面的 <strong>xxxUpdater</strong> 是更新下游的标准函数；xxxConverter是默认提供的json协议的标准化converter，用户可以根据自己的实际业务需要，基于自己的协议实现自己的converter，只需要保证满足 <code>PropertyConverter</code> 函数的定义以及入参出参语义就OK。</p>\n<h2>数据源抽象设计</h2>\n<p>数据源的抽象通过接口 <code>Datasource</code> 来定义，一个<code>Datasource</code> 可能会有多个下游的property handler来处理。<code>Datasource</code>的职责就是负责建立与配置中心中间件建立长连接，基于类似于Watcher的监听机制监听具体property的变化，并将property变化通过下游的property handler来处理。下面是接口的定义：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-comment\">// The generic interface to describe the datasource</span>\n<span class=\"hljs-comment\">// Each DataSource instance listen in one property type.</span>\n<span class=\"hljs-keyword\">type</span> DataSource <span class=\"hljs-keyword\">interface</span> {\n\t<span class=\"hljs-comment\">// Add specified property handler in current datasource</span>\n\tAddPropertyHandler(h PropertyHandler)\n\t<span class=\"hljs-comment\">// Remove specified property handler in current datasource</span>\n\tRemovePropertyHandler(h PropertyHandler)\n\t<span class=\"hljs-comment\">// Read original data from the data source.</span>\n\t<span class=\"hljs-comment\">// return source bytes if succeed to read, if not, return error when reading</span>\n\tReadSource() ([]<span class=\"hljs-keyword\">byte</span>, error)\n\t<span class=\"hljs-comment\">// Initialize the datasource and load initial rules</span>\n\t<span class=\"hljs-comment\">// start listener to listen on dynamic source</span>\n\t<span class=\"hljs-comment\">// return error if initialize failed;</span>\n\t<span class=\"hljs-comment\">// once initialized, listener should recover all panic and error.</span>\n\tInitialize() error\n\t<span class=\"hljs-comment\">// Close the data source.</span>\n\tio.Closer\n}\n</code></pre>\n<p>这里主要有两个函数需要介绍下：</p>\n<ol>\n<li>ReadSource：基于watcher机制，从watcher读取最新的property数据。</li>\n<li>Initialize：这里需要创建property的watcher，并通过一个单独的goroutine来监听watcher上的事件并处理相应的事件。</li>\n</ol>\n<p>DataSource是一个非常抽象的接口，所有具体数据源扩展的实现都需要实现这个接口。Sentinel 封装了一些数据源通用的逻辑到 dataSource.Base里面，这里主要是与handlers相关的，具体代码可能参考：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> Base <span class=\"hljs-keyword\">struct</span> {\n\thandlers []PropertyHandler\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(b *Base)</span> <span class=\"hljs-title\">Handlers</span><span class=\"hljs-params\">()</span> []<span class=\"hljs-title\">PropertyHandler</span></span> {\n\t<span class=\"hljs-keyword\">return</span> b.handlers\n}\n\n<span class=\"hljs-comment\">// return idx if existed, else return -1</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(b *Base)</span> <span class=\"hljs-title\">indexOfHandler</span><span class=\"hljs-params\">(h PropertyHandler)</span> <span class=\"hljs-title\">int</span></span> {\n\t<span class=\"hljs-keyword\">for</span> idx, handler := <span class=\"hljs-keyword\">range</span> b.handlers {\n\t\t<span class=\"hljs-keyword\">if</span> handler == h {\n\t\t\t<span class=\"hljs-keyword\">return</span> idx\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(b *Base)</span> <span class=\"hljs-title\">AddPropertyHandler</span><span class=\"hljs-params\">(h PropertyHandler)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> h == <span class=\"hljs-literal\">nil</span> || b.indexOfHandler(h) &gt;= <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tb.handlers = <span class=\"hljs-built_in\">append</span>(b.handlers, h)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(b *Base)</span> <span class=\"hljs-title\">RemovePropertyHandler</span><span class=\"hljs-params\">(h PropertyHandler)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> h == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tidx := b.indexOfHandler(h)\n\t<span class=\"hljs-keyword\">if</span> idx &lt; <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tb.handlers = <span class=\"hljs-built_in\">append</span>(b.handlers[:idx], b.handlers[idx+<span class=\"hljs-number\">1</span>:]...)\n}\n</code></pre>\n<p>主要包括一个DataSource相关的 handlers的定义以及相关增删。</p>\n<h1>Example: refresh file datasource:</h1>\n<p>为了方便开发者理解，Sentinel 提供了一个基于文件的数据源的example, 具体代码可以参考：<a href=\"https://github.com/alibaba/sentinel-golang/tree/master/ext/datasource/file\">refreshable_file.go</a></p>\n<h1>Use case</h1>\n<h2>app instance复用etcd长连接的场景：</h2>\n<p>etcd client 和 server 底层的数据交换是基于gRPC的，gRPC使用的是http2的长连接。所以比较期待的是每个应用的instance存在多个动态Property时候，能够复用一个长连接。</p>\n<p>etcd client与Server保持长连接是基于 clientv3/client.go里面的<a href=\"https://github.com/etcd-io/etcd/blob/0eee733220fc766ff0d193d61d9124aa06493986/clientv3/client.go#L72\">Client struct</a>。Sentinel期望不管用户在一个 APP instance上不管创建多少个动态 property 的数据源，都能够复用一个 etcd 的长连接。</p>\n<p>下面提供了一个demo 伪代码实现：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-keyword\">type</span> DatasourceGenerator <span class=\"hljs-keyword\">struct</span> {\n\tetcdv3Client *clientv3.Client\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewDatasourceGenerator</span><span class=\"hljs-params\">(config *clientv3.Config)</span> *<span class=\"hljs-title\">DatasourceGenerator</span></span> {\n\tclient, err := clientv3.New(*config)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tlogging.GetDefaultLogger().Errorf(<span class=\"hljs-string\">\"Fail to instance clientv3 Client, err: %+v\"</span>, err)\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t}\n\t<span class=\"hljs-keyword\">return</span> &amp;DatasourceGenerator{etcdv3Client: client}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(g *DatasourceGenerator)</span> <span class=\"hljs-title\">Generate</span><span class=\"hljs-params\">(key <span class=\"hljs-keyword\">string</span>, handlers ...datasource.PropertyHandler)</span> <span class=\"hljs-params\">(*Etcdv3DataSource, error)</span></span> {\n\t<span class=\"hljs-keyword\">var</span> err error\n\t<span class=\"hljs-keyword\">if</span> g.etcdv3Client == <span class=\"hljs-literal\">nil</span> {\n\t\terr = errors.New(<span class=\"hljs-string\">\"The etcdv3 client is nil in DatasourceGenerator\"</span>)\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, err\n\t}\n\tds := &amp;Etcdv3DataSource{\n\t\tclient:      g.etcdv3Client,\n\t\tpropertyKey: key,\n\t}\n\t<span class=\"hljs-keyword\">for</span> _, h := <span class=\"hljs-keyword\">range</span> handlers {\n\t\tds.AddPropertyHandler(h)\n\t}\n\t<span class=\"hljs-keyword\">return</span> ds, err\n}\n</code></pre>\n<p>实际使用的demo：</p>\n<pre><code class=\"language-go\">etcdv3Gen := NewDatasourceGenerator()\n<span class=\"hljs-keyword\">if</span> etcdv3Gen == <span class=\"hljs-literal\">nil</span> {\n    logger.Errorf(<span class=\"hljs-string\">\"Fail to instance etcdv3 datasource generator.\"</span>)\n    <span class=\"hljs-keyword\">return</span>\n}\nds1 := etcdv3Gen.Generate(key, handle...)\nds2 := etcdv3Gen.Generate(key, handle...)\nds3 := etcdv3Gen.Generate(key, handle...)\n......\n</code></pre>\n<h2>一个动态property关联一个动态数据源场景</h2>\n<p>Suppose现在property是system rules, property的下游也只有system manager。test code如下：</p>\n<pre><code class=\"language-go\">ds := NewFileDataSource(TestSystemRulesFile, NewSystemRulesHandler(SystemRulesJsonConverter))\nerr = ds.Initialize()\n</code></pre>\n<h2>一个动态property使用一个动态数据源，但是下游存在联动场景</h2>\n<p>先介绍下联动场景的背景：在集群模式下，Server端维护了一个namespaceSet(这里namespace表示的是每一个client的unique描述)，这个namespaceSet property 通过动态数据源来维护，做动态更新。</p>\n<p>集群模式下，client其实是一个非常轻的存在，所有的集群流控check实际上都是在Server端来做的，Server端维护了每一个client端的流控rules以及动态数据源。用伪代码来表示，Server端维护了一个map：namespace -&gt; datasource，这里map的value的每一个datasource表示一个client的流控规则的动态数据源，所以client的更新实际上是在Server端来做的。</p>\n<p>这个时候有一个场景：假设Server端的 namespaceSet property 动态数据源做了一个update，更改了namespaceSet(也就是client端存在增删情况)，这时候Server端也需要做对应数据源的增删，也就是联动场景。</p>\n<p>这种场景下，需要添加一个中间层，这个中间层的主要职责是维护 namespace -&gt; datasource 的map关系，并且根据上游 namespaceSet的动态更新，更新中间层的数据。</p>\n<p>基于现有DataSource的设计，给出联动场景的伪代码：</p>\n<pre><code class=\"language-go\">namespacesDatasource := NewDatasource(key, handlers{NamespacesJsonConverter, NamespacesUpdater}...)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NamespacesJsonConverter</span><span class=\"hljs-params\">(src []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">interface</span>{}, error)</span></span>{\n    <span class=\"hljs-comment\">// return namespaces string list.</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NamespacesUpdater</span><span class=\"hljs-params\">(value <span class=\"hljs-keyword\">interface</span>{})</span> <span class=\"hljs-title\">error</span></span> {\n    <span class=\"hljs-comment\">// Call ClusterDatasourceManager.LoadNamespaces()</span>\n}\n\n\n<span class=\"hljs-comment\">// 中间层</span>\n<span class=\"hljs-comment\">// datasource generator</span>\n<span class=\"hljs-keyword\">type</span> Generator <span class=\"hljs-keyword\">struct</span> {\n\n}\n\n<span class=\"hljs-keyword\">type</span> ClusterDatasourceManager <span class=\"hljs-keyword\">struct</span>{\n    datasourceGenerator Generator\n    <span class=\"hljs-comment\">//namespace -&gt; Datasource</span>\n    clientDatasource <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]datasource.Datasource\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">LoadNamespaces</span><span class=\"hljs-params\">(namespaces []<span class=\"hljs-keyword\">string</span>)</span></span>{\n    <span class=\"hljs-comment\">//check diff between current namespaces and the keys of clientDatasource</span>\n    <span class=\"hljs-comment\">// call generator to generate new datasource.</span>\n    <span class=\"hljs-comment\">// thread safe to update clientDatasource</span>\n}\n--------------------------------------------------------------------\n<span class=\"hljs-comment\">// 集群流控规则manager</span>\n<span class=\"hljs-keyword\">type</span> ClusterFlowRuleManager <span class=\"hljs-keyword\">struct</span> {\n   <span class=\"hljs-comment\">// namespace -&gt; rule list</span>\n   clientRules <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>][]*FlowRule\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">LoadNamespaceRules</span><span class=\"hljs-params\">(namespace <span class=\"hljs-keyword\">string</span>, rules []*flow.Rules)</span></span>{\n\n}\n</code></pre>\n<h2>多个动态property type共享一个数据源</h2>\n<p>假设现在存在多个property type: system rules, flow rules, circuit breaker rules. 期望通过一个动态compound property就能实现动态更新这三种类型的sub property。</p>\n<p>假设 property schema 大概是这样：</p>\n<pre><code class=\"language-json\">{\n    <span class=\"hljs-attr\">\"systemRules\"</span>:{\n    },\n    <span class=\"hljs-attr\">\"flowRules\"</span>:{\n    },\n    <span class=\"hljs-attr\">\"cbRules\"</span>:{\n    }\n}\n</code></pre>\n<p>基于现有DataSource extension的design是可以实现的。用户需要创建三个数据源 systemRulesDS,flowRulesDS,cbRulesDS，伪代码如下：</p>\n<pre><code class=\"language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">SystemRulesConverter</span><span class=\"hljs-params\">(src []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">interface</span>{}, error)</span></span> {\n    <span class=\"hljs-number\">1.</span> Decode src to Property <span class=\"hljs-keyword\">struct</span>\n    <span class=\"hljs-number\">2.</span> get systemRules related data\n    <span class=\"hljs-number\">3.</span> <span class=\"hljs-keyword\">return</span> system Rule list.\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">FlowRulesConverter</span><span class=\"hljs-params\">(src []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">interface</span>{}, error)</span></span> {\n    <span class=\"hljs-number\">1.</span> Decode src to Property <span class=\"hljs-keyword\">struct</span>\n    <span class=\"hljs-number\">2.</span> get flowRules related data\n    <span class=\"hljs-number\">3.</span> <span class=\"hljs-keyword\">return</span> flow Rule list.\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">cbRulesConverter</span><span class=\"hljs-params\">(src []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">interface</span>{}, error)</span></span> {\n    <span class=\"hljs-number\">1.</span> Decode src to Property <span class=\"hljs-keyword\">struct</span>\n    <span class=\"hljs-number\">2.</span> get cbRules related data\n    <span class=\"hljs-number\">3.</span> <span class=\"hljs-keyword\">return</span> cb Rule list.\n}\n\n<span class=\"hljs-comment\">// new system rules datasource</span>\nsystemRulesDS := NewDatasource(propertyLocation, NewDefaultPropertyHandler(SystemRulesConverter, SystemRulesUpdater));\n<span class=\"hljs-comment\">// new flow rules datasource</span>\nflowRulesDS := NewDatasource(propertyLocation, NewDefaultPropertyHandler(FlowRulesConverter, FlowRulesUpdater));\n<span class=\"hljs-comment\">// new cb rules datasource</span>\ncbRulesDS := NewDatasource(propertyLocation, NewDefaultPropertyHandler(CbRulesConverter, CbRulesUpdater));\n\nsystemRulesDS.Initialize()\nflowRulesDS.Initialize()\ncbRulesDS.Initialize()\n</code></pre>\n"
}