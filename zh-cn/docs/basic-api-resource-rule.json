{
  "filename": "basic-api-resource-rule.md",
  "__html": "<h1>基本使用 - 资源与规则</h1>\n<h2>简介</h2>\n<p>我们说的资源，可以是任何东西，服务，服务里的方法，甚至是一段代码。使用 Sentinel 来进行资源保护，主要分为两个步骤:</p>\n<ol>\n<li>定义资源</li>\n<li>定义规则</li>\n</ol>\n<p>先把可能需要保护的资源定义好，之后再配置规则。也可以理解为，只要有了资源，我们就可以在任何时候灵活地定义各种流量控制规则。在编码的时候，只需要考虑这个代码是否需要保护，如果需要保护，就将之定义为一个资源。</p>\n<p>对于主流的框架，我们提供适配，只需要按照适配中的说明配置，Sentinel 就会默认定义提供的服务，方法等为资源。</p>\n<h2>定义资源</h2>\n<h3>抛出异常的方式定义资源</h3>\n<p><code>SphU</code> 包含了 try-catch 风格的 API。用这种方式，当资源发生了限流之后会抛出 <code>BlockException</code>。这个时候可以捕捉异常，进行限流之后的逻辑处理。示例代码如下:</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 1.5.0 版本开始可以利用 try-with-resources 特性</span>\n<span class=\"hljs-comment\">// 资源名可使用任意有业务语义的字符串，比如方法名、接口名或其它可唯一标识的字符串。</span>\n<span class=\"hljs-keyword\">try</span> (Entry entry = SphU.entry(<span class=\"hljs-string\">\"resourceName\"</span>)) {\n  <span class=\"hljs-comment\">// 被保护的业务逻辑</span>\n  <span class=\"hljs-comment\">// do something here...</span>\n} <span class=\"hljs-keyword\">catch</span> (BlockException ex) {\n  <span class=\"hljs-comment\">// 资源访问阻止，被限流或被降级</span>\n  <span class=\"hljs-comment\">// 在此处进行相应的处理操作</span>\n}\n</code></pre>\n<p><strong>特别地</strong>，若 entry 的时候传入了热点参数，那么 exit 的时候也一定要带上对应的参数（<code>exit(count, args)</code>），否则可能会有统计错误。这个时候不能使用 try-with-resources 的方式。另外通过 <code>Tracer.trace(ex)</code> 来统计异常信息时，由于 try-with-resources 语法中 catch 调用顺序的问题，会导致无法正确统计异常数，因此统计异常信息时也不能在 try-with-resources 的 catch 块中调用 <code>Tracer.trace(ex)</code>。</p>\n<p>1.5.0 之前的版本的示例：</p>\n<pre><code class=\"language-java\">Entry entry = <span class=\"hljs-keyword\">null</span>;\n<span class=\"hljs-comment\">// 务必保证finally会被执行</span>\n<span class=\"hljs-keyword\">try</span> {\n  <span class=\"hljs-comment\">// 资源名可使用任意有业务语义的字符串</span>\n  entry = SphU.entry(<span class=\"hljs-string\">\"自定义资源名\"</span>);\n  <span class=\"hljs-comment\">// 被保护的业务逻辑</span>\n  <span class=\"hljs-comment\">// do something...</span>\n} <span class=\"hljs-keyword\">catch</span> (BlockException e1) {\n  <span class=\"hljs-comment\">// 资源访问阻止，被限流或被降级</span>\n  <span class=\"hljs-comment\">// 进行相应的处理操作</span>\n} <span class=\"hljs-keyword\">finally</span> {\n  <span class=\"hljs-keyword\">if</span> (entry != <span class=\"hljs-keyword\">null</span>) {\n    entry.exit();\n  }\n}\n</code></pre>\n<p><strong>注意：</strong> <code>SphU.entry(xxx)</code> 需要与 <code>entry.exit()</code> 方法成对出现，匹配调用，否则会导致调用链记录异常，抛出 <code>ErrorEntryFreeException</code> 异常。</p>\n<h3>返回布尔值方式定义资源</h3>\n<p>用这种方式，当资源发生了限流之后会返回 <code>false</code>，这个时候可以根据返回值，进行限流之后的逻辑处理。示例代码如下:</p>\n<pre><code class=\"language-java\">  <span class=\"hljs-comment\">// 资源名可使用任意有业务语义的字符串</span>\n  <span class=\"hljs-keyword\">if</span> (SphO.entry(<span class=\"hljs-string\">\"自定义资源名\"</span>)) {\n    <span class=\"hljs-comment\">// 务必保证finally会被执行</span>\n    <span class=\"hljs-keyword\">try</span> {\n      <span class=\"hljs-comment\">/**\n      * 被保护的业务逻辑\n      */</span>\n    } <span class=\"hljs-keyword\">finally</span> {\n      SphO.exit();\n    }\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// 资源访问阻止，被限流或被降级</span>\n    <span class=\"hljs-comment\">// 进行相应的处理操作</span>\n  }\n</code></pre>\n<h3>注解方式定义资源</h3>\n<p>Sentinel 支持通过 <code>@SentinelResource</code> 注解定义资源并配置 <code>blockHandler</code> 和 <code>fallback</code> 函数来进行限流之后的处理。示例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 原本的业务方法.</span>\n<span class=\"hljs-meta\">@SentinelResource</span>(blockHandler = <span class=\"hljs-string\">\"blockHandlerForGetUser\"</span>)\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> User <span class=\"hljs-title\">getUserById</span><span class=\"hljs-params\">(String id)</span> </span>{\n    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(<span class=\"hljs-string\">\"getUserById command failed\"</span>);\n}\n\n<span class=\"hljs-comment\">// blockHandler 函数，原方法调用被限流/降级/系统保护的时候调用</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> User <span class=\"hljs-title\">blockHandlerForGetUser</span><span class=\"hljs-params\">(String id, BlockException ex)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> User(<span class=\"hljs-string\">\"admin\"</span>);\n}\n</code></pre>\n<p>注意 <code>blockHandler</code> 函数会在原方法被限流/降级/系统保护的时候调用，而 <code>fallback</code> 函数会针对所有类型的异常。请注意 <code>blockHandler</code> 和 <code>fallback</code> 函数的形式要求，更多指引可以参见 <a href=\"./annotation-support.md\">Sentinel 注解扩展文档</a>。</p>\n<h3>业务异常统计</h3>\n<p>如果用户通过 <code>SphU</code> 或 <code>SphO</code> 手动定义资源，则 Sentinel 不能感知上层业务的异常，需要手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常，否则对应的异常不会统计到 Sentinel 异常计数中。</p>\n<p>从 1.4.0 版本开始，注解方式定义资源支持自动统计业务异常，无需手动调用 <code>Tracer.trace(ex)</code> 来记录业务异常。Sentinel 1.4.0 以前的版本需要手动记录。</p>\n<h3>判断限流降级异常</h3>\n<p>通过以下方法判断：</p>\n<pre><code class=\"language-java\">BlockException.isBlockException(Throwable t);\n</code></pre>\n<h3>异步调用支持</h3>\n<p>Sentinel 从 0.2.0 版本开始支持异步调用资源的定义。在异步调用中，需要通过 <code>SphU.asyncEntry(xxx)</code> 方法定义资源，并通常需要在异步的回调函数中调用 <code>exit</code> 方法。以下是一个简单的示例：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">try</span> {\n    AsyncEntry entry = SphU.asyncEntry(resourceName);\n\n    <span class=\"hljs-comment\">// 异步调用.</span>\n    doAsync(userId, result -&gt; {\n        <span class=\"hljs-keyword\">try</span> {\n            <span class=\"hljs-comment\">// 在此处处理异步调用的结果.</span>\n        } <span class=\"hljs-keyword\">finally</span> {\n            <span class=\"hljs-comment\">// 在回调结束后 exit.</span>\n            entry.exit();\n        }\n    });\n} <span class=\"hljs-keyword\">catch</span> (BlockException ex) {\n    <span class=\"hljs-comment\">// Request blocked.</span>\n    <span class=\"hljs-comment\">// Handle the exception (e.g. retry or fallback).</span>\n}\n</code></pre>\n<p><code>SphU.asyncEntry(xxx)</code> 不会影响当前（调用线程）的 Context，因此以下两个 entry 在调用链上是平级关系（处于同一层），而不是嵌套关系：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 调用链类似于：</span>\n<span class=\"hljs-comment\">// -parent</span>\n<span class=\"hljs-comment\">// ---asyncResource</span>\n<span class=\"hljs-comment\">// ---syncResource</span>\nasyncEntry = SphU.asyncEntry(asyncResource);\nentry = SphU.entry(normalResource);\n</code></pre>\n<p>若在异步回调中需要嵌套其它的资源调用（无论是 <code>entry</code> 还是 <code>asyncEntry</code>），只需要借助 Sentinel 提供的上下文切换功能，在对应的地方通过 <code>ContextUtil.runOnContext(context, f)</code> 进行 Context 变换，将对应资源调用处的 Context 切换为生成的异步 Context，即可维持正确的调用链路关系。示例如下：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">handleResult</span><span class=\"hljs-params\">(String result)</span> </span>{\n    Entry entry = <span class=\"hljs-keyword\">null</span>;\n    <span class=\"hljs-keyword\">try</span> {\n        entry = SphU.entry(<span class=\"hljs-string\">\"handleResultForAsync\"</span>);\n        <span class=\"hljs-comment\">// Handle your result here.</span>\n    } <span class=\"hljs-keyword\">catch</span> (BlockException ex) {\n        <span class=\"hljs-comment\">// Blocked for the result handler.</span>\n    } <span class=\"hljs-keyword\">finally</span> {\n        <span class=\"hljs-keyword\">if</span> (entry != <span class=\"hljs-keyword\">null</span>) {\n            entry.exit();\n        }\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">someAsync</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-keyword\">try</span> {\n        AsyncEntry entry = SphU.asyncEntry(resourceName);\n\n        <span class=\"hljs-comment\">// Asynchronous invocation.</span>\n        doAsync(userId, result -&gt; {\n            <span class=\"hljs-comment\">// 在异步回调中进行上下文变换，通过 AsyncEntry 的 getAsyncContext 方法获取异步 Context</span>\n            ContextUtil.runOnContext(entry.getAsyncContext(), () -&gt; {\n                <span class=\"hljs-keyword\">try</span> {\n                    <span class=\"hljs-comment\">// 此处嵌套正常的资源调用.</span>\n                    handleResult(result);\n                } <span class=\"hljs-keyword\">finally</span> {\n                    entry.exit();\n                }\n            });\n        });\n    } <span class=\"hljs-keyword\">catch</span> (BlockException ex) {\n        <span class=\"hljs-comment\">// Request blocked.</span>\n        <span class=\"hljs-comment\">// Handle the exception (e.g. retry or fallback).</span>\n    }\n}\n</code></pre>\n<p>此时的调用链就类似于：</p>\n<pre><code>-parent\n---asyncInvocation\n-----handleResultForAsync\n</code></pre>\n<p>更详细的示例可以参考 Demo 中的 <a href=\"https://github.com/alibaba/Sentinel/blob/master/sentinel-demo/sentinel-demo-basic/src/main/java/com/alibaba/csp/sentinel/demo/AsyncEntryDemo.java\">AsyncEntryDemo</a>，里面包含了普通资源与异步资源之间的各种嵌套示例。</p>\n<h2>主流框架的适配</h2>\n<p>为了减少开发的复杂程度，我们对大部分的主流框架，例如 Dubbo, RocketMQ, Spring Cloud 等都做了适配。您只需要引入对应的依赖，它们的方法，服务，都会进行默认的埋点。</p>\n<p>参见: <a href=\"./open-source-framework-integrations.md\">主流框架的适配</a></p>\n<h2>定义规则</h2>\n<p>Sentinel 的所有规则都可以在内存态中动态地查询及修改，修改之后立即生效。同时 Sentinel 也提供相关 API，供您来定制自己的规则策略。</p>\n<h3>规则的定义</h3>\n<p>Sentinel 支持以下几种规则：<strong>流量控制规则</strong>、<strong>熔断降级规则</strong>、<strong>系统保护规则</strong> 以及 <strong>授权规则</strong>。</p>\n<h3>流量控制规则 (FlowRule)</h3>\n<h4>流量规则的定义</h4>\n<p>重要属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">resource</td>\n<td style=\"text-align:left\">资源名，资源名是限流规则的作用对象</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:left\">限流阈值</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">grade</td>\n<td style=\"text-align:left\">限流阈值类型，是按照 QPS 还是线程数</td>\n<td style=\"text-align:left\">QPS 模式</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">limitApp</td>\n<td style=\"text-align:left\">是否根据调用者来限流</td>\n<td style=\"text-align:left\">否</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">strategy</td>\n<td style=\"text-align:left\">判断的根据是资源自身，还是根据其它资源 (<code>refResource</code>)，还是根据链路入口 (<code>refResource</code>)</td>\n<td style=\"text-align:left\">根据资源本身</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">controlBehavior</td>\n<td style=\"text-align:left\">发生拦截后的流量整形和控制策略（直接拒绝 / 排队等待 / 慢启动模式）</td>\n<td style=\"text-align:left\">直接拒绝</td>\n</tr>\n</tbody>\n</table>\n<p>同一个资源可以同时有多个限流规则。</p>\n<h4>通过代码定义流量控制规则</h4>\n<p>理解上面规则的定义之后，我们可以通过调用 <code>FlowRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则，比如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initFlowQpsRule</span><span class=\"hljs-params\">()</span> </span>{\n        List&lt;FlowRule&gt; rules = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        FlowRule rule1 = <span class=\"hljs-keyword\">new</span> FlowRule();\n        rule1.setResource(KEY);\n        <span class=\"hljs-comment\">// set limit qps to 20</span>\n        rule1.setCount(<span class=\"hljs-number\">20</span>);\n        rule1.setGrade(RuleConstant.FLOW_GRADE_QPS);\n        rule1.setLimitApp(<span class=\"hljs-string\">\"default\"</span>);\n        rules.add(rule1);\n        FlowRuleManager.loadRules(rules);\n    }\n</code></pre>\n<p>更多详细内容可以参考 <a href=\"./flow-control.md\">流量控制</a>。</p>\n<h3>熔断降级规则 (DegradeRule)</h3>\n<p>熔断降级规则包含下面几个重要的属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">resource</td>\n<td style=\"text-align:left\">资源名，资源名是限流规则的作用对象</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:left\">限流阈值</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">grade</td>\n<td style=\"text-align:left\">降级模式，根据 RT 降级还是根据异常比例降级</td>\n<td style=\"text-align:left\">RT</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">timeWindow</td>\n<td style=\"text-align:left\">降级的时间</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<p>同一个资源可以同时有多个降级规则。</p>\n<p>理解上面规则的定义之后，我们可以通过调用 <code>DegradeRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则。</p>\n<pre><code class=\"language-java\"> <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initDegradeRule</span><span class=\"hljs-params\">()</span> </span>{\n        List&lt;DegradeRule&gt; rules = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n        DegradeRule rule = <span class=\"hljs-keyword\">new</span> DegradeRule();\n        rule.setResource(KEY);\n        <span class=\"hljs-comment\">// set threshold rt, 10 ms</span>\n        rule.setCount(<span class=\"hljs-number\">10</span>);\n        rule.setGrade(RuleConstant.DEGRADE_GRADE_RT);\n        rule.setTimeWindow(<span class=\"hljs-number\">10</span>);\n        rules.add(rule);\n        DegradeRuleManager.loadRules(rules);\n    }\n</code></pre>\n<p>更多详情可以参考 <a href=\"./circuit-breaking.md\">熔断降级</a>。</p>\n<h3>系统保护规则 (SystemRule)</h3>\n<p>规则包含下面几个重要的属性：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Field</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">highestSystemLoad</td>\n<td style=\"text-align:left\">最大的 <code>load1</code>，参考值</td>\n<td style=\"text-align:left\">-1 (不生效)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">avgRt</td>\n<td style=\"text-align:left\">所有入口流量的平均响应时间</td>\n<td style=\"text-align:left\">-1 (不生效)</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">maxThread</td>\n<td style=\"text-align:left\">入口流量的最大并发数</td>\n<td style=\"text-align:left\">-1 (不生效)</td>\n</tr>\n</tbody>\n</table>\n<p>理解上面规则的定义之后，我们可以通过调用 <code>SystemRuleManager.loadRules()</code> 方法来用硬编码的方式定义流量控制规则。</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initSystemProtectionRule</span><span class=\"hljs-params\">()</span> </span>{\n  List&lt;SystemRule&gt; rules = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;();\n  SystemRule rule = <span class=\"hljs-keyword\">new</span> SystemRule();\n  rule.setHighestSystemLoad(<span class=\"hljs-number\">10</span>);\n  rules.add(rule);\n  SystemRuleManager.loadRules(rules);\n}\n</code></pre>\n<p>更多详情可以参考 <a href=\"./system-adaptive-protection.md\">系统负载保护</a>。</p>\n<h3>查询更改规则</h3>\n<p>运行下面命令，则会返回现有生效的规则：</p>\n<pre><code class=\"language-shell\">curl http://localhost:8719/getRules?type=&lt;XXXX&gt;\n</code></pre>\n<p>其中，<code>type=flow</code> 以 JSON 格式返回现有的限流规则；degrade 则返回现有生效的降级规则列表；system 则返回系统保护规则。</p>\n<p>同时也可以通过下面命令来修改已有规则：</p>\n<pre><code class=\"language-shell\">curl http://localhost:8719/setRules?type=&lt;XXXX&gt;&amp;data=&lt;DATA&gt;\n</code></pre>\n<p>其中，type 可以输入 <code>flow</code>、<code>degrade</code> 等方式来制定更改的规则种类，<code>data</code> 则是对应的 JSON 格式的规则。</p>\n<h2>定制自己的持久化规则</h2>\n<p>上面的规则配置，都是存在内存中的。即如果应用重启，这个规则就会失效。因此我们提供了开放的接口，您可以通过实现 <a href=\"https://github.com/alibaba/Sentinel/blob/master/sentinel-extension/sentinel-datasource-extension/src/main/java/com/alibaba/csp/sentinel/datasource/AbstractDataSource.java\"><code>DataSource</code></a> 接口的方式，来自定义规则的存储数据源。通常我们的建议有：</p>\n<ul>\n<li>整合动态配置系统，如 ZooKeeper、<a href=\"https://github.com/alibaba/Nacos\">Nacos</a> 等，动态地实时刷新配置规则</li>\n<li>结合 RDBMS、NoSQL、VCS 等来实现该规则</li>\n<li>配合 Sentinel Dashboard 使用</li>\n</ul>\n<p>更多详情请参考 <a href=\"./dynamic-rule-configuration.md\">动态规则配置</a>。</p>\n<h1>规则生效的效果</h1>\n<p>除了在业务代码逻辑上看到规则生效，我们也可以通过下面简单的方法，来校验规则生效的效果：</p>\n<ul>\n<li><strong>暴露的 HTTP 接口</strong>：通过运行下面命令 <code>curl http://localhost:8719/cnode?id=&lt;资源名称&gt;</code>，观察返回的数据。如果规则生效，在返回的数据栏中的 <code>block</code> 以及 <code>block(m)</code> 中会有显示</li>\n<li><strong>日志</strong>：Sentinel 提供秒级的资源运行日志以及限流日志，详情可以参考: <a href=\"./logs.md\">日志</a></li>\n</ul>\n"
}