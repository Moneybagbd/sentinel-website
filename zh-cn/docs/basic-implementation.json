{
  "filename": "basic-implementation.md",
  "__html": "<h1>Sentinel 工作主流程</h1>\n<h2>Overview</h2>\n<p>在 Sentinel 里面，所有的资源都对应一个资源名称以及一个 Entry。Entry 可以通过对主流框架的适配自动创建，也可以通过注解的方式或调用 API 显式创建；每一个 Entry 创建的时候，同时也会创建一系列功能插槽（slot chain）。这些插槽有不同的职责，例如:</p>\n<ul>\n<li><code>NodeSelectorSlot</code> 负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级；</li>\n<li><code>ClusterBuilderSlot</code> 则用于存储资源的统计信息以及调用者信息，例如该资源的 RT, QPS, thread count 等等，这些信息将用作为多维度限流，降级的依据；</li>\n<li><code>StatisticSlot</code> 则用于记录、统计不同纬度的 runtime 指标监控信息；</li>\n<li><code>FlowSlot</code> 则用于根据预设的限流规则以及前面 slot 统计的状态，来进行流量控制；</li>\n<li><code>AuthoritySlot</code> 则根据配置的黑白名单和调用来源信息，来做黑白名单控制；</li>\n<li><code>DegradeSlot</code> 则通过统计信息以及预设的规则，来做熔断降级；</li>\n<li><code>SystemSlot</code> 则通过系统的状态，例如 load1 等，来控制总的入口流量；</li>\n</ul>\n<p>总体的框架如下:</p>\n<p><img src=\"./img/sentinel-slot-chain-architecture.png\" alt=\"arch overview\"></p>\n<p>Sentinel 将 <code>ProcessorSlot</code> 作为 SPI 接口进行扩展（1.7.2 版本以前 <code>SlotChainBuilder</code> 作为 SPI），使得 Slot Chain 具备了扩展的能力。您可以自行加入自定义的 slot 并编排 slot 间的顺序，从而可以给 Sentinel 添加自定义的功能。</p>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/46783631-93324d00-cd5d-11e8-8ad1-a802bcc8f9c9.png\" alt=\"Slot Chain SPI\"></p>\n<p>下面介绍一下各个 slot 的功能。</p>\n<h2>NodeSelectorSlot</h2>\n<p>这个 slot 主要负责收集资源的路径，并将这些资源的调用路径，以树状结构存储起来，用于根据调用路径来限流降级。</p>\n<pre><code class=\"language-java\"> ContextUtil.enter(<span class=\"hljs-string\">\"entrance1\"</span>, <span class=\"hljs-string\">\"appA\"</span>);\n Entry nodeA = SphU.entry(<span class=\"hljs-string\">\"nodeA\"</span>);\n <span class=\"hljs-keyword\">if</span> (nodeA != <span class=\"hljs-keyword\">null</span>) {\n    nodeA.exit();\n }\n ContextUtil.exit();\n</code></pre>\n<p>上述代码通过 <code>ContextUtil.enter()</code> 创建了一个名为 <code>entrance1</code> 的上下文，同时指定调用发起者为 <code>appA</code>；接着通过  <code>SphU.entry()</code>请求一个 token，如果该方法顺利执行没有抛 <code>BlockException</code>，表明 token 请求成功。</p>\n<p>以上代码将在内存中生成以下结构：</p>\n<pre><code> \t     machine-root\n                 /     \n                /\n         EntranceNode1\n              /\n             /   \n      DefaultNode(nodeA)\n</code></pre>\n<p>注意：每个 <code>DefaultNode</code> 由资源 ID 和输入名称来标识。换句话说，一个资源 ID 可以有多个不同入口的 DefaultNode。</p>\n<pre><code class=\"language-java\">  ContextUtil.enter(<span class=\"hljs-string\">\"entrance1\"</span>, <span class=\"hljs-string\">\"appA\"</span>);\n  Entry nodeA = SphU.entry(<span class=\"hljs-string\">\"nodeA\"</span>);\n  <span class=\"hljs-keyword\">if</span> (nodeA != <span class=\"hljs-keyword\">null</span>) {\n    nodeA.exit();\n  }\n  ContextUtil.exit();\n\n  ContextUtil.enter(<span class=\"hljs-string\">\"entrance2\"</span>, <span class=\"hljs-string\">\"appA\"</span>);\n  nodeA = SphU.entry(<span class=\"hljs-string\">\"nodeA\"</span>);\n  <span class=\"hljs-keyword\">if</span> (nodeA != <span class=\"hljs-keyword\">null</span>) {\n    nodeA.exit();\n  }\n  ContextUtil.exit();\n</code></pre>\n<p>以上代码将在内存中生成以下结构：</p>\n<pre><code>                   machine-root\n                   /         \\\n                  /           \\\n          EntranceNode1   EntranceNode2\n                /               \\\n               /                 \\\n       DefaultNode(nodeA)   DefaultNode(nodeA)\n</code></pre>\n<p>上面的结构可以通过调用 <code>curl http://localhost:8719/tree?type=root</code> 来显示：</p>\n<pre><code>EntranceNode: machine-root(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)\n-EntranceNode1: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)\n--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)\n-EntranceNode2: Entrance1(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)\n--nodeA(t:0 pq:1 bq:0 tq:1 rt:0 prq:1 1mp:0 1mb:0 1mt:0)\n\nt:threadNum  pq:passQps  bq:blockedQps  tq:totalQps  rt:averageRt  prq: passRequestQps 1mp:1m-passed 1mb:1m-blocked 1mt:1m-total\n</code></pre>\n<h2>ClusterBuilderSlot</h2>\n<p>此插槽用于构建资源的 <code>ClusterNode</code> 以及调用来源节点。<code>ClusterNode</code> 保持资源运行统计信息（响应时间、QPS、block 数目、线程数、异常数等）以及原始调用者统计信息列表。来源调用者的名字由 <code>ContextUtil.enter(contextName，origin)</code> 中的 <code>origin</code> 标记。可通过如下命令查看某个资源不同调用者的访问情况：<code>curl http://localhost:8719/origin?id=caller</code>：</p>\n<pre><code>id: nodeA\nidx origin  threadNum passedQps blockedQps totalQps aRt   1m-passed 1m-blocked 1m-total \n1   caller1 0         0         0          0        0     0         0          0        \n2   caller2 0         0         0          0        0     0         0          0        \n</code></pre>\n<h2>StatisticSlot</h2>\n<p><code>StatisticSlot</code> 是 Sentinel 的核心功能插槽之一，用于统计实时的调用数据。</p>\n<ul>\n<li><code>clusterNode</code>：资源唯一标识的 ClusterNode 的 runtime 统计</li>\n<li><code>origin</code>：根据来自不同调用者的统计信息</li>\n<li><code>defaultnode</code>: 根据上下文条目名称和资源 ID 的 runtime 统计</li>\n<li>入口的统计</li>\n</ul>\n<p>Sentinel 底层采用高性能的滑动窗口数据结构 <code>LeapArray</code> 来统计实时的秒级指标数据，可以很好地支撑写多于读的高并发场景。</p>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/51955215-0af7c500-247e-11e9-8895-9fc0e4c10c8c.png\" alt=\"sliding-window-leap-array\"></p>\n<h2>FlowSlot</h2>\n<p>这个 slot 主要根据预设的资源的统计信息，按照固定的次序，依次生效。如果一个资源对应两条或者多条流控规则，则会根据如下次序依次检验，直到全部通过或者有一个规则生效为止:</p>\n<ul>\n<li>指定应用生效的规则，即针对调用方限流的；</li>\n<li>调用方为 other 的规则；</li>\n<li>调用方为 default 的规则。</li>\n</ul>\n<h2>DegradeSlot</h2>\n<p>这个 slot 主要针对资源的平均响应时间（RT）以及异常比率，来决定资源是否在接下来的时间被自动熔断掉。</p>\n<h2>SystemSlot</h2>\n<p>这个 slot 会根据对于当前系统的整体情况，对入口资源的调用进行动态调配。其原理是让入口的流量和当前系统的预计容量达到一个动态平衡。</p>\n<p>注意系统规则只对入口流量起作用（调用类型为 <code>EntryType.IN</code>），对出口流量无效。可通过 <code>SphU.entry(res, entryType)</code> 指定调用类型，如果不指定，默认是<code>EntryType.OUT</code>。</p>\n<h2>更多</h2>\n<ul>\n<li><a href=\"https://github.com/alibaba/Sentinel/wiki/Sentinel-%E6%A0%B8%E5%BF%83%E7%B1%BB%E8%A7%A3%E6%9E%90\">Sentinel 核心类解析</a></li>\n</ul>\n"
}