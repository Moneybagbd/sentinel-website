{
  "filename": "api-gateway-flow-control.md",
  "__html": "<h1>网关流量控制</h1>\n<p>Sentinel 支持对 Spring Cloud Gateway、Zuul 等主流的 API Gateway 进行限流。</p>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/58381714-266d7980-7ff3-11e9-8617-d0d7c325d703.png\" alt=\"sentinel-api-gateway-common-arch\"></p>\n<p>Sentinel 1.6.0 引入了 Sentinel API Gateway Adapter Common 模块，此模块中包含网关限流的规则和自定义 API 的实体和管理逻辑：</p>\n<ul>\n<li><code>GatewayFlowRule</code>：网关限流规则，针对 API Gateway 的场景定制的限流规则，可以针对不同 route 或自定义的 API 分组进行限流，支持针对请求中的参数、Header、来源 IP 等进行定制化的限流。</li>\n<li><code>ApiDefinition</code>：用户自定义的 API 定义分组，可以看做是一些 URL 匹配的组合。比如我们可以定义一个 API 叫 <code>my_api</code>，请求 path 模式为 <code>/foo/**</code> 和 <code>/baz/**</code> 的都归到 <code>my_api</code> 这个 API 分组下面。限流的时候可以针对这个自定义的 API 分组维度进行限流。</li>\n</ul>\n<p>其中网关限流规则 <code>GatewayFlowRule</code> 的字段解释如下：</p>\n<ul>\n<li><code>resource</code>：资源名称，可以是网关中的 route 名称或者用户自定义的 API 分组名称。</li>\n<li><code>resourceMode</code>：规则是针对 API Gateway 的 route（<code>RESOURCE_MODE_ROUTE_ID</code>）还是用户在 Sentinel 中定义的 API 分组（<code>RESOURCE_MODE_CUSTOM_API_NAME</code>），默认是 route。</li>\n<li><code>grade</code>：限流指标维度，同限流规则的 <code>grade</code> 字段。</li>\n<li><code>count</code>：限流阈值</li>\n<li><code>intervalSec</code>：统计时间窗口，单位是秒，默认是 1 秒。</li>\n<li><code>controlBehavior</code>：流量整形的控制效果，同限流规则的 <code>controlBehavior</code> 字段，目前支持快速失败和匀速排队两种模式，默认是快速失败。</li>\n<li><code>burst</code>：应对突发请求时额外允许的请求数目。</li>\n<li><code>maxQueueingTimeoutMs</code>：匀速排队模式下的最长排队时间，单位是毫秒，仅在匀速排队模式下生效。</li>\n<li><code>paramItem</code>：参数限流配置。若不提供，则代表不针对参数进行限流，该网关规则将会被转换成普通流控规则；否则会转换成热点规则。其中的字段：\n<ul>\n<li><code>parseStrategy</code>：从请求中提取参数的策略，目前支持提取来源 IP（<code>PARAM_PARSE_STRATEGY_CLIENT_IP</code>）、Host（<code>PARAM_PARSE_STRATEGY_HOST</code>）、任意 Header（<code>PARAM_PARSE_STRATEGY_HEADER</code>）和任意 URL 参数（<code>PARAM_PARSE_STRATEGY_URL_PARAM</code>）四种模式。</li>\n<li><code>fieldName</code>：若提取策略选择 Header 模式或 URL 参数模式，则需要指定对应的 header 名称或 URL 参数名称。</li>\n<li><code>pattern</code>：参数值的匹配模式，只有匹配该模式的请求属性值会纳入统计和流控；若为空则统计该请求属性的所有值。（1.6.2 版本开始支持）</li>\n<li><code>matchStrategy</code>：参数值的匹配策略，目前支持精确匹配（<code>PARAM_MATCH_STRATEGY_EXACT</code>）、子串匹配（<code>PARAM_MATCH_STRATEGY_CONTAINS</code>）和正则匹配（<code>PARAM_MATCH_STRATEGY_REGEX</code>）。（1.6.2 版本开始支持）</li>\n</ul>\n</li>\n</ul>\n<p>用户可以通过 <code>GatewayRuleManager.loadRules(rules)</code> 手动加载网关规则，或通过 <code>GatewayRuleManager.register2Property(property)</code> 注册动态规则源动态推送（推荐方式）。</p>\n<h2>Spring Cloud Gateway</h2>\n<p>从 1.6.0 版本开始，Sentinel 提供了 Spring Cloud Gateway 的适配模块，可以提供两种资源维度的限流：</p>\n<ul>\n<li>route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 routeId</li>\n<li>自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组</li>\n</ul>\n<p>使用时需引入以下模块（以 Maven 为例）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-spring-cloud-gateway-adapter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>使用时只需注入对应的 <code>SentinelGatewayFilter</code> 实例以及 <code>SentinelGatewayBlockExceptionHandler</code> 实例即可。比如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GatewayConfiguration</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> List&lt;ViewResolver&gt; viewResolvers;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> ServerCodecConfigurer serverCodecConfigurer;\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">GatewayConfiguration</span><span class=\"hljs-params\">(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,\n                                ServerCodecConfigurer serverCodecConfigurer)</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);\n        <span class=\"hljs-keyword\">this</span>.serverCodecConfigurer = serverCodecConfigurer;\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-meta\">@Order</span>(Ordered.HIGHEST_PRECEDENCE)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> SentinelGatewayBlockExceptionHandler <span class=\"hljs-title\">sentinelGatewayBlockExceptionHandler</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// Register the block exception handler for Spring Cloud Gateway.</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-meta\">@Order</span>(-<span class=\"hljs-number\">1</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> GlobalFilter <span class=\"hljs-title\">sentinelGatewayFilter</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SentinelGatewayFilter();\n    }\n}\n</code></pre>\n<p>Demo 示例：<a href=\"https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-spring-cloud-gateway\">sentinel-demo-spring-cloud-gateway</a></p>\n<p>比如我们在 Spring Cloud Gateway 中配置了以下路由：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">server:</span>\n<span class=\"hljs-attr\">  port:</span> <span class=\"hljs-number\">8090</span>\n<span class=\"hljs-attr\">spring:</span>\n<span class=\"hljs-attr\">  application:</span>\n<span class=\"hljs-attr\">    name:</span> <span class=\"hljs-string\">spring-cloud-gateway</span>\n<span class=\"hljs-attr\">  cloud:</span>\n<span class=\"hljs-attr\">    gateway:</span>\n<span class=\"hljs-attr\">      enabled:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">      discovery:</span>\n<span class=\"hljs-attr\">        locator:</span>\n<span class=\"hljs-attr\">          lower-case-service-id:</span> <span class=\"hljs-literal\">true</span>\n<span class=\"hljs-attr\">      routes:</span>\n        <span class=\"hljs-comment\"># Add your routes here.</span>\n<span class=\"hljs-attr\">        - id:</span> <span class=\"hljs-string\">product_route</span>\n<span class=\"hljs-attr\">          uri:</span> <span class=\"hljs-attr\">lb://product</span>\n<span class=\"hljs-attr\">          predicates:</span>\n<span class=\"hljs-bullet\">            -</span> <span class=\"hljs-string\">Path=/product/**</span>\n<span class=\"hljs-attr\">        - id:</span> <span class=\"hljs-string\">httpbin_route</span>\n<span class=\"hljs-attr\">          uri:</span> <span class=\"hljs-attr\">https://httpbin.org</span>\n<span class=\"hljs-attr\">          predicates:</span>\n<span class=\"hljs-bullet\">            -</span> <span class=\"hljs-string\">Path=/httpbin/**</span>\n<span class=\"hljs-attr\">          filters:</span>\n<span class=\"hljs-bullet\">            -</span> <span class=\"hljs-string\">RewritePath=/httpbin/(?&lt;segment&gt;.*),</span> <span class=\"hljs-string\">/$\\{segment}</span>\n</code></pre>\n<p>同时自定义了一些 API 分组：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">initCustomizedApis</span><span class=\"hljs-params\">()</span> </span>{\n    Set&lt;ApiDefinition&gt; definitions = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\n    ApiDefinition api1 = <span class=\"hljs-keyword\">new</span> ApiDefinition(<span class=\"hljs-string\">\"some_customized_api\"</span>)\n        .setPredicateItems(<span class=\"hljs-keyword\">new</span> HashSet&lt;ApiPredicateItem&gt;() {{\n            add(<span class=\"hljs-keyword\">new</span> ApiPathPredicateItem().setPattern(<span class=\"hljs-string\">\"/product/baz\"</span>));\n            add(<span class=\"hljs-keyword\">new</span> ApiPathPredicateItem().setPattern(<span class=\"hljs-string\">\"/product/foo/**\"</span>)\n                .setMatchStrategy(SentinelGatewayConstants.PARAM_MATCH_STRATEGY_PREFIX));\n        }});\n    ApiDefinition api2 = <span class=\"hljs-keyword\">new</span> ApiDefinition(<span class=\"hljs-string\">\"another_customized_api\"</span>)\n        .setPredicateItems(<span class=\"hljs-keyword\">new</span> HashSet&lt;ApiPredicateItem&gt;() {{\n            add(<span class=\"hljs-keyword\">new</span> ApiPathPredicateItem().setPattern(<span class=\"hljs-string\">\"/ahas\"</span>));\n        }});\n    definitions.add(api1);\n    definitions.add(api2);\n    GatewayApiDefinitionManager.loadApiDefinitions(definitions);\n}\n</code></pre>\n<p>那么这里面的 route ID（如 <code>product_route</code>）和 API name（如 <code>some_customized_api</code>）都会被标识为 Sentinel 的资源。比如访问网关的 URL 为 <code>http://localhost:8090/product/foo/22</code> 的时候，对应的统计会加到 <code>product_route</code> 和 <code>some_customized_api</code> 这两个资源上面，而 <code>http://localhost:8090/httpbin/json</code> 只会对应到 <code>httpbin_route</code> 资源上面。</p>\n<p>您可以在 <code>GatewayCallbackManager</code> 注册回调进行定制：</p>\n<ul>\n<li><code>setBlockHandler</code>：注册函数用于实现自定义的逻辑处理被限流的请求，对应接口为 <code>BlockRequestHandler</code>。默认实现为 <code>DefaultBlockRequestHandler</code>，当被限流时会返回类似于下面的错误信息：<code>Blocked by Sentinel: FlowException</code>。</li>\n</ul>\n<h2>Zuul 1.x</h2>\n<p>Sentinel 提供了 Zuul 1.x 的适配模块，可以为 Zuul Gateway 提供两种资源维度的限流：</p>\n<ul>\n<li>route 维度：即在 Spring 配置文件中配置的路由条目，资源名为对应的 route ID（对应 <code>RequestContext</code> 中的 <code>proxy</code> 字段）</li>\n<li>自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组</li>\n</ul>\n<p>使用时需引入以下模块（以 Maven 为例）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-zuul-adapter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>若使用的是 Spring Cloud Netflix Zuul，我们可以直接在配置类中将三个 filter 注入到 Spring 环境中即可：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ZuulConfig</span> </span>{\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ZuulFilter <span class=\"hljs-title\">sentinelZuulPreFilter</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// We can also provider the filter order in the constructor.</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SentinelZuulPreFilter();\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ZuulFilter <span class=\"hljs-title\">sentinelZuulPostFilter</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SentinelZuulPostFilter();\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> ZuulFilter <span class=\"hljs-title\">sentinelZuulErrorFilter</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> SentinelZuulErrorFilter();\n    }\n}\n</code></pre>\n<p>Sentinel Zuul Adapter 生成的调用链路类似于下面，其中的资源名都是 route ID 或者自定义的 API 分组名称：</p>\n<pre><code>-EntranceNode: sentinel_gateway_context$$route$$another-route-b(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:8 1mb:1 1mt:9)\n--another-route-b(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:4 1mb:1 1mt:5)\n--another_customized_api(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:4 1mb:0 1mt:4)\n-EntranceNode: sentinel_gateway_context$$route$$my-route-1(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:6 1mb:0 1mt:6)\n--my-route-1(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:2 1mb:0 1mt:2)\n--some_customized_api(t:0 pq:0.0 bq:0.0 tq:0.0 rt:0.0 prq:0.0 1mp:2 1mb:0 1mt:2)\n</code></pre>\n<p>发生限流之后的处理流程 ：</p>\n<ul>\n<li>发生限流之后可自定义返回参数，通过实现 <code>SentinelFallbackProvider</code> 接口，默认的实现是 <code>DefaultBlockFallbackProvider</code>。</li>\n<li>默认的 fallback route 的规则是 route ID 或自定义的 API 分组名称。</li>\n</ul>\n<p>比如：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// 自定义 FallbackProvider </span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyBlockFallbackProvider</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">ZuulBlockFallbackProvider</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> Logger logger = LoggerFactory.getLogger(DefaultBlockFallbackProvider.class);\n    \n    <span class=\"hljs-comment\">// you can define route as service level </span>\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title\">getRoute</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"/book/app\"</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> BlockResponse <span class=\"hljs-title\">fallbackResponse</span><span class=\"hljs-params\">(String route, Throwable cause)</span> </span>{\n            RecordLog.info(String.format(<span class=\"hljs-string\">\"[Sentinel DefaultBlockFallbackProvider] Run fallback route: %s\"</span>, route));\n            <span class=\"hljs-keyword\">if</span> (cause <span class=\"hljs-keyword\">instanceof</span> BlockException) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> BlockResponse(<span class=\"hljs-number\">429</span>, <span class=\"hljs-string\">\"Sentinel block exception\"</span>, route);\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> BlockResponse(<span class=\"hljs-number\">500</span>, <span class=\"hljs-string\">\"System Error\"</span>, route);\n            }\n        }\n }\n \n <span class=\"hljs-comment\">// 注册 FallbackProvider</span>\n ZuulBlockFallbackManager.registerProvider(<span class=\"hljs-keyword\">new</span> MyBlockFallbackProvider());\n</code></pre>\n<p>限流发生之后的默认返回：</p>\n<pre><code class=\"language-json\">{\n    <span class=\"hljs-attr\">\"code\"</span>:<span class=\"hljs-number\">429</span>,\n    <span class=\"hljs-attr\">\"message\"</span>:<span class=\"hljs-string\">\"Sentinel block exception\"</span>,\n    <span class=\"hljs-attr\">\"route\"</span>:<span class=\"hljs-string\">\"/\"</span>\n}\n</code></pre>\n<h2>Zuul 2.x</h2>\n<blockquote>\n<p>注：从 1.7.2 版本开始支持，需要 Java 8 及以上版本。</p>\n</blockquote>\n<p>Sentinel 提供了 Zuul 2.x 的适配模块，可以为 Zuul Gateway 提供两种资源维度的限流：</p>\n<ul>\n<li>route 维度：对应 SessionContext 中的 <code>routeVIP</code></li>\n<li>自定义 API 维度：用户可以利用 Sentinel 提供的 API 来自定义一些 API 分组</li>\n</ul>\n<p>使用时需引入以下模块（以 Maven 为例）：</p>\n<pre><code class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.csp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>sentinel-zuul2-adapter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>x.y.z<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>然后配置对应的 filter 即可：</p>\n<pre><code class=\"language-java\">filterMultibinder.addBinding().toInstance(<span class=\"hljs-keyword\">new</span> SentinelZuulInboundFilter(<span class=\"hljs-number\">500</span>));\nfilterMultibinder.addBinding().toInstance(<span class=\"hljs-keyword\">new</span> SentinelZuulOutboundFilter(<span class=\"hljs-number\">500</span>));\nfilterMultibinder.addBinding().toInstance(<span class=\"hljs-keyword\">new</span> SentinelZuulEndpoint());\n</code></pre>\n<p>可以参考 <a href=\"https://github.com/alibaba/Sentinel/tree/master/sentinel-demo/sentinel-demo-zuul2-gateway\">sentinel-demo-zuul2-gateway 示例</a>。</p>\n<h2>网关流控实现原理</h2>\n<p>当通过 <code>GatewayRuleManager</code> 加载网关流控规则（<code>GatewayFlowRule</code>）时，无论是否针对请求属性进行限流，Sentinel 底层都会将网关流控规则转化为热点参数规则（<code>ParamFlowRule</code>），存储在 <code>GatewayRuleManager</code> 中，与正常的热点参数规则相隔离。转换时 Sentinel 会根据请求属性配置，为网关流控规则设置参数索引（<code>idx</code>），并同步到生成的热点参数规则中。</p>\n<p>外部请求进入 API Gateway 时会经过 Sentinel 实现的 filter，其中会依次进行 <strong>路由/API 分组匹配</strong>、<strong>请求属性解析</strong>和<strong>参数组装</strong>。Sentinel 会根据配置的网关流控规则来解析请求属性，并依照参数索引顺序组装参数数组，最终传入 <code>SphU.entry(res, args)</code> 中。Sentinel API Gateway Adapter Common 模块向 Slot Chain 中添加了一个 <code>GatewayFlowSlot</code>，专门用来做网关规则的检查。<code>GatewayFlowSlot</code> 会从 <code>GatewayRuleManager</code> 中提取生成的热点参数规则，根据传入的参数依次进行规则检查。若某条规则不针对请求属性，则会在参数最后一个位置置入预设的常量，达到普通流控的效果。</p>\n<p><img src=\"https://user-images.githubusercontent.com/9434884/58381786-5406f280-7ff4-11e9-9020-016ccaf7ab7d.png\" alt=\"image\"></p>\n<h2>网关流控控制台</h2>\n<p>Sentinel 1.6.3 引入了网关流控控制台的支持，用户可以直接在 Sentinel 控制台上查看 API Gateway 实时的 route 和自定义 API 分组监控，管理网关规则和 API 分组配置。</p>\n<p>在 API Gateway 端，用户只需要在<a href=\"https://github.com/alibaba/Sentinel/wiki/%E6%8E%A7%E5%88%B6%E5%8F%B0#32-%E9%85%8D%E7%BD%AE%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0\">原有启动参数</a>的基础上添加如下启动参数即可标记应用为 API Gateway 类型：</p>\n<pre><code class=\"language-bash\"><span class=\"hljs-comment\"># 注：通过 Spring Cloud Alibaba Sentinel 自动接入的 API Gateway 整合则无需此参数</span>\n-Dcsp.sentinel.app.type=1\n</code></pre>\n<p>添加正确的启动参数并有访问量后，我们就可以在 Sentinel 上面看到对应的 API Gateway 了。我们可以查看实时的 route 和自定义 API 分组的监控和调用信息：</p>\n<p><img src=\"https://sentinelguard.io/blog/zh-cn/img/sentinel-dashboard-api-gateway-route-list.png\" alt=\"sentinel-dashboard-api-gateway-route-list\"></p>\n<p>我们可以在控制台配置自定义的 API 分组，将一些 URL 匹配模式归为一个 API 分组：</p>\n<p><img src=\"https://sentinelguard.io/blog/zh-cn/img/sentinel-dashboard-api-gateway-customized-api-group.png\" alt=\"sentinel-dashboard-api-gateway-customized-api-group\"></p>\n<p>然后我们可以在控制台针对预设的 route ID 或自定义的 API 分组配置网关流控规则：</p>\n<p><img src=\"https://sentinelguard.io/blog/zh-cn/img/sentinel-dashboard-api-gateway-flow-rule.png\" alt=\"sentinel-dashboard-api-gateway-flow-rule\"></p>\n<p>云上版本可以参考 <a href=\"https://help.aliyun.com/document_detail/118482.html\">AHAS 网关流控</a>。</p>\n"
}